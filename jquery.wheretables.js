// ## Introduction

/**
 * **whereTables** is a [jQuery](http://www.jquery.com) plugin that give you
 * the ability to toggle the visibility of certain columns in a table. This
 * plugin is `colspan` aware, but does not yet work with `rowspan`. This
 * library is over-engineered for the purpose of proposing an architecture to
 * the team in an effort to get feedback and establish some structure for
 * future javascript work.
 *
 * This documentation was generated by running the
 * [source code](jquery.wheretables.js) through the 
 [Rocco](https://github.com/rtomayko/rocco) ruby gem.
 *
 * ### Prerequisites
 *
 * whereTables depends on the [jQuery](http://www.jquery.com) library so it
 * must already be included on the page. Following that, you'll need to include
 * this library. You can do so with the following, adjusting the path as
 * necessary:
 *
 *     <script src="/path/tp/jquery.wheretables.js"></script>
 *
 * ### Initialization
 *
 * After including whereTables, initialize it by calling `.whereTables()`
 * on the elements you want it applied to (e.g., `$('table')` or
 * `$('table.toggleColumns')`).
 * 
 * ### To-Do List
 * * Add support for rowspan.
 */

// Immediately-executing anonymous function (closure!). `window` and
// `undefined` are pulled into the local scope for performance and
// data-integrity.
( function( $, window, undefined ){

// ## Class Definition

  /**
   * We start by creating a `whereTables` "class" that takes two parameters:
   * `target` which is the target element and `id` which is the numeric id of
   * this instance. `id` could be pulled out but I'm leaving it as a function
   * parameter in case I add the ability to reuse removed ids.
   */

  var whereTables = function( target, id ){

    // ### Private Variables

    /**
     * **Note**: I like to prefix jquery objects with `$` but that is purely a
     * personal convention.
     *
     * Set `self` to `this` to hold a reference to the current scope.
     */

    var self = this,
      $target = $( target ),
      columnStates,
      columnVisibility = [];
 
    // ### Public Variables

    /**
     * The repeated declaration is just to provide a shorthand reference to
     * the variable (read-only for primitives). The current variables are:
     *
     * * `id`: An auto-incremented value for this instance.
     *
     * * `columnCount`: The calculated number of columns (this is colspan
     *   aware).
     *
     * * `elements`: A hash that contains all the relevant elements or—in
     *   other words—everything on the dom the javascript would want to
     *   talk to. Sort of worthless here since we're not generating anything
     *   new, and we're only holding onto the `target`.
     */

    self.id = id;
    self.columnCount = columnCount = false;
    self.elements = elements = {
      target: target
    };

    // ### Initialization

    /**
     * **Note**: I would consider putting the following in an init method.
     *
     * Count the number of columns intelligently and save their current
     * visibility in columnVisibility for quick lookups.
     */

    for (var c = self.columnCount = countColumns(), i = 0; i<c; i++ ){
      columnVisibility.push( true );
    }

    // Add column number classes to the table cells.
    writeColumnPositions();

    // ### Private Methods

    // #### writeColumnPositions

    /**
     * `writeColumnPositions` adds classes to table cells indicating their
     * which columns they are in. I cannot rely on selectors because of colspan
     * so I've chosen to explicitly map this stuff out.
     */

    function writeColumnPositions( ){
      
      var colspanBias;

      // For each `tr` in the `target` element
      $( 'tr', elements.target ).each( function( x, v ){
        // reset the `colspan` bias,
        colspanBias = 0;
        // find each table cell (`th`, `td`),
        $( 'th, td', this ).each( function( y, v ){
          var $this = $( this ),
            colspan = $this.attr( 'colspan' );
          // and add a `class` for the current column.
          $this.addClass( 'WC-ypos-' + ( y + colspanBias ) );
          // If it has a `colspan` of more than `1`,
          if ( colspan > 0 ){
            // add each subsequent `class`.
            for ( var c = 1; c < colspan; c++ ){
              $this.addClass( 'WC-ypos-' + ( y + colspanBias + c ) );
            }

            //increase the `colspan` bias accordingly.
            colspanBias += colspan - 1;
          }
        } );
      } );

    }

    // #### toggleColumnVisibility

    /**
     * `toggleColumnVisibility` shows or hides columns intelligently (taking
     * `colspan` into account). It takes two parameters:
     *
     * * `index`: the column number (zero index).
     *
     * * `visible`: _optional_. If true, shows the column. If false, hides it.
     *   If omitted, toggles the current state.
     */

    function toggleColumnVisibility( index, visible ){

      // Find all the relevant table cells.
      var
        $allElems = $('td.WC-ypos-' + index + ', th.WC-ypos-' + index, elements.target ),
        // isolate them by those with a colspan
        $colspanElems = $allElems.filter('[colspan]'),
        // and those without.
        $singleElems = $allElems.not('[colspan]');
      // if `visible` is omitted, toggle the current state and, regardless,
      // save the new visible state in the columnVisibility array.
      columnVisibility[index] = visible = visible | ! columnVisibility[index];
      // Set non-`colspan` elements to the right visibility.
      $singleElems.css( 'display', visible?'table-cell':'none' );
      // for each `colspan` elements
      $colspanElems.each( function(){
        var $this = $(this);
        var columnsVisible = 0;
        // find out which columns it takes up
        var indexes = $.map( $this.attr('class').split(' '), function(v){
          return (v.split('-'))[2];
        } );
        // then check which of those columns is visible.
        $.each( indexes, function(){
          if ( columnVisibility[this] ) columnsVisible += 1;
        } );
        // If none of them are visible, hide that table-cell.
        if ( columnsVisible === 0 ) {
          $this.attr( 'colspan', 1 ).css( 'display', 'none' );
        // Otherwise, reduce the `colspan` and make sure it's visible.
        } else {
          $this
            .attr( 'colspan', columnsVisible )
            .css( 'display', 'table-cell' );
        }

      } );

      /**
       * Trigger an event to signify a column has been shown or hidden.
       * Either a `showColumn.whereTables` or `hideColumn.whereTables` event
       * will be emitted from the `target` element with one argument that holds
       * the `index` of the affected column.
       *
       * This is useful for when you want to tie additional functionality to
       * when a column is shown or hidden, outside of this plugin. For example,
       * to make an alert pop up with the column `index` when a column is
       * shown, you could use something like the following:
       *
       *     $(targetObject).bind(
       *         'showColumn.whereTables',
       *         function( event, index ){
       *             alert( index );
       *         }
       *     );
       */
      $target.trigger( (visible?'show':'hide') + 'Column.whereTables', [index] );
    }

    // #### countColumns

    /**
     * `countColumns` intelligently counts the maximum number of columns by
     * taking `colspan` into account. Memoizes the value unless you pass in
     * the _optional_ parameter `forceRefresh` with a value of `true`.
     */

    function countColumns( forceRefresh ){

      // If we've already calculated a value or we're `forceRefresh`, return
      // the previous value.
      if ( ! forceRefresh && columnCount ) return columnCount;

      var cols = 0;

      // for the first `tr` in `target`
      $( 'tr:first', elements.target )
        // find all the table-cells
        .children( 'td, th' )
        // and count them up (including `colspan`).
        .each( function(i,v){
          cols += $(this).attr( 'colspan' ) || 1;
        } );
      
      return cols;

    }

    // ### Public Methods (API)

    /**
     * Everything within this section is callable from the `api` object (talked
     * about below). They're all pretty self explanatory.
     */

    $.extend(self, {

      // I stick debug methods in here.
      DEBUG: {
        // Print out the (private) `columnVisibility` array.
        printColumnVisibility: function(){
          WT.log( columnVisibility );
        }
      },

      // `hideColumn` takes an `index` as a parameter, and hides that column.
      hideColumn: function( index ){
        toggleColumnVisibility( index, false );
      },

      // `toggleColumn` takes an `index` as a parameter, and toggles that
      // column.
      toggleColumn: function( index ){
        toggleColumnVisibility( index );
      },

      // `showColumn` takes an `index` as a parameter, and shows that column.
      showColumn: function( index ){
        toggleColumnVisibility( index, true );
      }

    } );

  };

  var WT = $.fn.whereTables = function( request ){

    if ( "string" === typeof request && "" !== request ) {
      if ( request === 'api' ) return $( this[0] ).data('whereTables');
      var args = Array.prototype.slice.call(arguments, 1);
      return this.each( function(){
        var api = $( this ).data('whereTables');
        if ( api && api[request] ){
          api[request].apply( api[request], args );
        } else {
          if ( 'undefined' === typeof api )
            WT.log ( 'whereTables not initialized on %o', this );
          else
            WT.log ( 'Cannot find API method: %s', request );
        }
      } );
    }

    return this.each( function(){

      var id = WT.nextid++;

      var $this = $( this );
      var obj = new whereTables( this, id );
      $this.data( 'whereTables', obj );

    } );

  };

  WT.nextid = 0;

  WT.log = function( ){
    if ( window.console && console.log )
      console.log.apply( console, arguments );
  };

} ) ( jQuery, window );
